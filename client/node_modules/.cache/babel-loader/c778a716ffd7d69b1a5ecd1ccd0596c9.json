{"ast":null,"code":"var _jsxFileName = \"/Users/griffinbaker/Desktop/chat-application/client/src/components/add-user-dropdown/add-user-dropdown.component.jsx\",\n    _s = $RefreshSig$();\n\nimport { Fragment, useState, useEffect, useRef } from 'react';\nimport { useAuthentication } from '../../contexts/authentication-context';\nimport { useChatView } from '../../contexts/chat-view-context';\nimport { TOAST_TYPE, defaultToast } from '../../utils/utils';\nimport SearchResult, { SEARCH_RESULT_TYPE } from '../search-result/search-result-component';\nimport './add-user-dropdown.styles.scss'; // If there is a solo chat, can add the user, but need to add another user to an existing chat as opposed to create an entirely new one. Also, need to make an adjustment once the chat goes from solo to group.\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst AddUserDropdown = _ref => {\n  _s();\n\n  let {\n    wasSoloChat\n  } = _ref;\n  const [userSearchResults, setUserSearchResults] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const addUserToChatRef = useRef();\n  const {\n    currentUser\n  } = useAuthentication();\n  const {\n    activeChat,\n    fetchChats,\n    showAddUserInfoDropdown,\n    chats\n  } = useChatView();\n  console.log('was solo chat from user dd', wasSoloChat);\n  useEffect(() => {\n    if (!addUserToChatRef.current) return;\n    addUserToChatRef.current.focus();\n  }, [showAddUserInfoDropdown]);\n\n  const handleTextChange = async e => {\n    const query = e.target.value;\n\n    if (!query) {\n      setUserSearchResults([]);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const response = await fetch(`http://localhost:4000/api/user?search=${query}`, {\n        method: 'get',\n        headers: {\n          Authorization: `Bearer ${currentUser.token}`\n        }\n      });\n      const {\n        users\n      } = await response.json();\n      const usersNotAlreadyInChat = users.filter(returnedUser => {\n        return !activeChat[0].users.some(chatUser => returnedUser.userName === chatUser.userName);\n      });\n      setIsLoading(false);\n      setUserSearchResults(usersNotAlreadyInChat); // May also want to filter these by who is not in the curent chat, or could do this on the back end as well but may not be the right nove there, but could jsut incluce a little flag to hanle on the BE\n    } catch (e) {\n      defaultToast(TOAST_TYPE.error, 'User already exists in chat');\n    }\n  };\n\n  const handleAddUser = async e => {\n    const closestContainer = e.target.closest('.add-user-to-existing-chat-container');\n    const selectedId = closestContainer.getAttribute('name'); // const alreadyExistsInCurrentChat = activeChat[0].users.some(\n    //   user => user._id === selectedId\n    // );\n    // if (alreadyExistsInCurrentChat) {\n    //   defaultToast(TOAST_TYPE.failure, 'Error adding user');\n    //   return;\n    // }\n    // Search for if a chat already exists between the user that was just added\n    // const alreadyExists = chats.some(chat => chat.users);\n\n    const mappedChatWithNames = chats.map(chat => chat.users.map(_ref2 => {\n      let {\n        userName\n      } = _ref2;\n      return userName;\n    }).sort());\n    console.log(userSearchResults);\n    const selectedUser = userSearchResults.find(user => user._id === selectedId);\n    console.log(selectedUser);\n    const sortedChatUsers = [activeChat[0].users];\n    console.log(sortedChatUsers);\n    return;\n\n    try {\n      const response = await fetch('http://localhost:4000/api/chat/addUserToChat', {\n        method: 'put',\n        headers: {\n          Authorization: `Bearer ${currentUser.token}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          chatId: activeChat[0]._id,\n          userId: selectedId\n        })\n      });\n      const newChat = await response.json();\n      fetchChats();\n      defaultToast(TOAST_TYPE.success, 'User successfully added');\n    } catch (error) {\n      defaultToast(TOAST_TYPE.failure, 'Error adding user');\n    } // setChatParticipants(prevState => [...prevState, selectedUser]);\n    // setFormInput(prevState => ({ ...prevState, name: '' }));\n\n  };\n\n  const handleLeaveChat = e => {// Here Ia m going to need to see who the current user is and then send them to the backend and then I guess just refetch the chats? Is that what he does just to reset everything? I guess that make sure the whole state is current\n  }; // const addUserInputRef = useRef();\n  // const handleKeyDown = e => {\n  //   console.log('hello?');\n  // };\n  // useEffect(() => {\n  //   if (!addUserInputRef.current) return;\n  //   const keypress = new Event('keydown', {\n  //     bubbles: true,\n  //     cancelable: true,\n  //     keycode: 32,\n  //     which: 32,\n  //   });\n  //   addUserInputRef.current.focus();\n  //   addUserInputRef.current.dispatchEvent(keypress);\n  // }, [showAddUserDropdown]);\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"add-user-dropdown-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"add-user-dropdown-tip bottom\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"add-user-dropdown-content-container\",\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"search\",\n          placeholder: \"Search users...\",\n          onChange: handleTextChange,\n          ref: addUserToChatRef\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 148,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"add-user-dropdown-results-container\",\n          children: userSearchResults.map((searchResult, i) => /*#__PURE__*/_jsxDEV(Fragment, {\n            children: /*#__PURE__*/_jsxDEV(SearchResult, {\n              type: SEARCH_RESULT_TYPE.addUserToExistingChat,\n              handleAddUser: handleAddUser,\n              searchResult: searchResult\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 157,\n              columnNumber: 17\n            }, this)\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 156,\n            columnNumber: 15\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 154,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 147,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 145,\n    columnNumber: 5\n  }, this);\n};\n\n_s(AddUserDropdown, \"BS9fDbfKD/1XKdc/HinHeAzFF/U=\", false, function () {\n  return [useAuthentication, useChatView];\n});\n\n_c = AddUserDropdown;\nexport default AddUserDropdown;\n\nvar _c;\n\n$RefreshReg$(_c, \"AddUserDropdown\");","map":{"version":3,"names":["Fragment","useState","useEffect","useRef","useAuthentication","useChatView","TOAST_TYPE","defaultToast","SearchResult","SEARCH_RESULT_TYPE","AddUserDropdown","wasSoloChat","userSearchResults","setUserSearchResults","isLoading","setIsLoading","addUserToChatRef","currentUser","activeChat","fetchChats","showAddUserInfoDropdown","chats","console","log","current","focus","handleTextChange","e","query","target","value","response","fetch","method","headers","Authorization","token","users","json","usersNotAlreadyInChat","filter","returnedUser","some","chatUser","userName","error","handleAddUser","closestContainer","closest","selectedId","getAttribute","mappedChatWithNames","map","chat","sort","selectedUser","find","user","_id","sortedChatUsers","body","JSON","stringify","chatId","userId","newChat","success","failure","handleLeaveChat","searchResult","i","addUserToExistingChat"],"sources":["/Users/griffinbaker/Desktop/chat-application/client/src/components/add-user-dropdown/add-user-dropdown.component.jsx"],"sourcesContent":["import { Fragment, useState, useEffect, useRef } from 'react';\nimport { useAuthentication } from '../../contexts/authentication-context';\nimport { useChatView } from '../../contexts/chat-view-context';\nimport { TOAST_TYPE, defaultToast } from '../../utils/utils';\nimport SearchResult, {\n  SEARCH_RESULT_TYPE,\n} from '../search-result/search-result-component';\nimport './add-user-dropdown.styles.scss';\n\n// If there is a solo chat, can add the user, but need to add another user to an existing chat as opposed to create an entirely new one. Also, need to make an adjustment once the chat goes from solo to group.\n\nconst AddUserDropdown = ({ wasSoloChat }) => {\n  const [userSearchResults, setUserSearchResults] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const addUserToChatRef = useRef();\n\n  const { currentUser } = useAuthentication();\n  const { activeChat, fetchChats, showAddUserInfoDropdown, chats } =\n    useChatView();\n\n  console.log('was solo chat from user dd', wasSoloChat);\n\n  useEffect(() => {\n    if (!addUserToChatRef.current) return;\n    addUserToChatRef.current.focus();\n  }, [showAddUserInfoDropdown]);\n\n  const handleTextChange = async e => {\n    const query = e.target.value;\n    if (!query) {\n      setUserSearchResults([]);\n      return;\n    }\n    try {\n      setIsLoading(true);\n      const response = await fetch(\n        `http://localhost:4000/api/user?search=${query}`,\n        {\n          method: 'get',\n          headers: { Authorization: `Bearer ${currentUser.token}` },\n        }\n      );\n      const { users } = await response.json();\n\n      const usersNotAlreadyInChat = users.filter(returnedUser => {\n        return !activeChat[0].users.some(\n          chatUser => returnedUser.userName === chatUser.userName\n        );\n      });\n\n      setIsLoading(false);\n\n      setUserSearchResults(usersNotAlreadyInChat);\n\n      // May also want to filter these by who is not in the curent chat, or could do this on the back end as well but may not be the right nove there, but could jsut incluce a little flag to hanle on the BE\n    } catch (e) {\n      defaultToast(TOAST_TYPE.error, 'User already exists in chat');\n    }\n  };\n\n  const handleAddUser = async e => {\n    const closestContainer = e.target.closest(\n      '.add-user-to-existing-chat-container'\n    );\n    const selectedId = closestContainer.getAttribute('name');\n\n    // const alreadyExistsInCurrentChat = activeChat[0].users.some(\n    //   user => user._id === selectedId\n    // );\n\n    // if (alreadyExistsInCurrentChat) {\n    //   defaultToast(TOAST_TYPE.failure, 'Error adding user');\n    //   return;\n    // }\n\n    // Search for if a chat already exists between the user that was just added\n    // const alreadyExists = chats.some(chat => chat.users);\n\n    const mappedChatWithNames = chats.map(chat =>\n      chat.users.map(({ userName }) => userName).sort()\n    );\n\n    console.log(userSearchResults);\n\n    const selectedUser = userSearchResults.find(\n      user => user._id === selectedId\n    );\n\n    console.log(selectedUser);\n\n    const sortedChatUsers = [activeChat[0].users];\n\n    console.log(sortedChatUsers);\n\n    return;\n\n    try {\n      const response = await fetch(\n        'http://localhost:4000/api/chat/addUserToChat',\n        {\n          method: 'put',\n          headers: {\n            Authorization: `Bearer ${currentUser.token}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            chatId: activeChat[0]._id,\n            userId: selectedId,\n          }),\n        }\n      );\n      const newChat = await response.json();\n      fetchChats();\n      defaultToast(TOAST_TYPE.success, 'User successfully added');\n    } catch (error) {\n      defaultToast(TOAST_TYPE.failure, 'Error adding user');\n    }\n\n    // setChatParticipants(prevState => [...prevState, selectedUser]);\n    // setFormInput(prevState => ({ ...prevState, name: '' }));\n  };\n\n  const handleLeaveChat = e => {\n    // Here Ia m going to need to see who the current user is and then send them to the backend and then I guess just refetch the chats? Is that what he does just to reset everything? I guess that make sure the whole state is current\n  };\n  // const addUserInputRef = useRef();\n\n  // const handleKeyDown = e => {\n  //   console.log('hello?');\n  // };\n\n  // useEffect(() => {\n  //   if (!addUserInputRef.current) return;\n  //   const keypress = new Event('keydown', {\n  //     bubbles: true,\n  //     cancelable: true,\n  //     keycode: 32,\n  //     which: 32,\n  //   });\n  //   addUserInputRef.current.focus();\n  //   addUserInputRef.current.dispatchEvent(keypress);\n  // }, [showAddUserDropdown]);\n\n  return (\n    <div className=\"add-user-dropdown-container\">\n      <div className=\"add-user-dropdown-tip bottom\">\n        <div className=\"add-user-dropdown-content-container\">\n          <input\n            type=\"search\"\n            placeholder=\"Search users...\"\n            onChange={handleTextChange}\n            ref={addUserToChatRef}\n          />\n          <div className=\"add-user-dropdown-results-container\">\n            {userSearchResults.map((searchResult, i) => (\n              <Fragment key={i}>\n                <SearchResult\n                  type={SEARCH_RESULT_TYPE.addUserToExistingChat}\n                  handleAddUser={handleAddUser}\n                  searchResult={searchResult}\n                />\n              </Fragment>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AddUserDropdown;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
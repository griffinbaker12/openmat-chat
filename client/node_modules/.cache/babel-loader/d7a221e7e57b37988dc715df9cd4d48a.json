{"ast":null,"code":"var _jsxFileName = \"/Users/griffinbaker/Desktop/chat-application/client/src/contexts/chat-view-context.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { useAuthentication } from './authentication-context';\nimport { toast } from 'react-toastify';\nimport { useNavigate } from 'react-router-dom'; // import { useSocket } from './socket-context';\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatViewContext = /*#__PURE__*/createContext();\nexport const useChatView = () => {\n  _s();\n\n  return useContext(ChatViewContext);\n};\n\n_s(useChatView, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport const SIDEBAR_CATEGORY_TYPE = {\n  conversations: 'conversations',\n  friends: 'friends'\n};\nexport const MODAL_TYPE = {\n  sidebar: 'sidebar',\n  chatInfo: 'chatInfo',\n  userInfo: 'userInfo'\n};\nexport const ChatViewProvider = _ref => {\n  _s2();\n\n  let {\n    children\n  } = _ref;\n  const [activeChat, setActiveChat] = useState([]);\n  const [search, setSearch] = useState('');\n  const [isChatViewLoading, setIsChatViewLoading] = useState(false);\n  const [searchResults, setSearchResults] = useState([]);\n  const [sideBarCategory, setSideBarCategory] = useState(SIDEBAR_CATEGORY_TYPE.conversations);\n  const [showModal, setShowModal] = useState(false);\n  const [showAddUserInfoDropdown, setShowAddUserInfoDropdown] = useState(false);\n  const [modalType, setModalType] = useState('');\n  const [chats, setChats] = useState([]);\n  const [activeUserInfo, setActiveUserInfo] = useState(null);\n  const [isActiveUserCurrentUser, setIsActiveUserCurrentUser] = useState(false);\n  const [showActiveUserWithinChatInfo, setShowActiveUserWithinChatInfo] = useState(false);\n  const [activeView, setActiveView] = useState('chat');\n  const [windowDimensions, setWindowDimensions] = useState({\n    height: window.innerHeight,\n    width: window.innerWidth\n  });\n  const [notifications, setNotifications] = useState([]);\n  const [reloadCircuit, setReloadCircuit] = useState(false);\n  const [unreadMessages, setUnreadMessages] = useState([]);\n  const {\n    currentUser,\n    setCurrentUser,\n    setIsLoading\n  } = useAuthentication();\n  const navigate = useNavigate();\n\n  const closeModal = () => {\n    if (showAddUserInfoDropdown) {\n      setShowAddUserInfoDropdown(false);\n      return;\n    }\n\n    setShowModal(false);\n  };\n\n  const setUserInfoModal = async function (id) {\n    let currentUserFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (currentUserFlag) {\n      setActiveUserInfo(currentUser);\n      setIsActiveUserCurrentUser(true);\n      setShowActiveUserWithinChatInfo(true);\n      return;\n    }\n\n    const response = await fetch(`http://localhost:4000/api/user/getUserInfo?id=${id}`, {\n      method: 'get',\n      headers: {\n        Authorization: `Bearer ${currentUser.token}`\n      }\n    });\n    const user = await response.json();\n    setActiveUserInfo(user);\n  };\n\n  const updateSearchValue = e => setSearch(e.target.value);\n\n  const fetchChats = useCallback(async function () {\n    let tokenForLogin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let userData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    setIsChatViewLoading(true);\n    setIsLoading(true);\n\n    try {\n      const response = await fetch(`http://localhost:4000/api/chat`, {\n        method: 'get',\n        headers: {\n          Authorization: `Bearer ${tokenForLogin || currentUser.token}`\n        }\n      });\n      const data = await response.json();\n      setIsChatViewLoading(false);\n      setIsLoading(false);\n      setChats(data);\n\n      if (tokenForLogin) {\n        navigate('/chat');\n        toast.success('Login success', {\n          position: 'bottom-center',\n          autoClose: 3000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n          progress: undefined,\n          theme: 'dark'\n        });\n        setCurrentUser(userData);\n      }\n    } catch (e) {\n      setIsChatViewLoading(false);\n      toast.error('Error fetching chats', {\n        position: 'bottom-center',\n        autoClose: 3000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: 'dark'\n      });\n    }\n  }, [currentUser, navigate, setIsLoading, setCurrentUser]);\n  const fetchNotifications = useCallback(async function () {\n    let tokenForLogin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    try {\n      const response = await fetch(`http://localhost:4000/api/notification`, {\n        method: 'get',\n        headers: {\n          Authorization: `Bearer ${tokenForLogin || currentUser.token}`\n        }\n      });\n      const notifications = await response.json();\n      console.log(notifications, 'notifications');\n      setNotifications(notifications); // const chatAndReadStatus = [];\n      // if (notifications.length === 0) return;\n      // notifications.forEach(notification => {\n      //   const alreadyInCounterIndex = chatAndReadStatus.findIndex(\n      //     notificaitonInChatCounter =>\n      //       notificaitonInChatCounter.chat._id ===\n      //       notification.message.chat._id\n      //   );\n      //   if (alreadyInCounterIndex >= 0) {\n      //     let objToInc = chatAndReadStatus[alreadyInCounterIndex];\n      //     objToInc.count = objToInc.count + 1;\n      //   } else {\n      //     chatAndReadStatus.push({ notification, read: false });\n      //   }\n      // });\n    } catch (error) {\n      toast.error('Error fetching notifications', {\n        position: 'bottom-center',\n        autoClose: 3000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: 'dark'\n      });\n    }\n  }, [currentUser]);\n\n  const handleModal = modalType => {\n    setModalType(modalType);\n    setShowModal(true);\n  };\n\n  const handleSearchSubmit = async e => {\n    e.preventDefault();\n    if (!search) return;\n\n    try {\n      setIsChatViewLoading(true); // I almost like the feature where you keep the search text there so that you know what you searched, and then once you hit the x then the results unfilter and are based off of the time the last message was sent\n      // setSearch('');\n\n      const response = await fetch(`http://localhost:4000/api/user?search=${search}`, {\n        method: 'get',\n        headers: {\n          Authorization: `Bearer ${currentUser.token}`\n        }\n      });\n      const {\n        messages,\n        users\n      } = await response.json();\n      setIsChatViewLoading(false);\n      setSearchResults([{\n        messages,\n        users\n      }]);\n    } catch (e) {\n      toast.error('Error fetching results', {\n        position: 'bottom-center',\n        autoClose: 3000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: 'dark'\n      });\n    }\n  }; // Fetch the chats once, and then otherwise just add the chats to the data, don't need to re-fetch or anything like that. Could keep this here or do something where you only fetch the chats and the friends once the user is actually signed in. That could also be a route where you just find these two things\n\n\n  useEffect(() => {\n    if (!currentUser) {\n      setChats([]);\n      setActiveChat([]);\n      return;\n    }\n\n    if (currentUser._id) {\n      fetchChats();\n      fetchNotifications();\n    }\n\n    return;\n  }, [currentUser, fetchChats, setIsLoading, fetchNotifications]);\n  useEffect(() => {\n    if (chats.length === 0 || reloadCircuit) {\n      return;\n    } else {\n      const activeChat = chats[0];\n      setActiveChat([activeChat]);\n    }\n  }, [chats, reloadCircuit]); // useEffect(() => {\n  //   if (!currentUser) return;\n  //   setFriends(currentUser.friends);\n  // }, [currentUser]);\n\n  return /*#__PURE__*/_jsxDEV(ChatViewContext.Provider, {\n    value: {\n      activeChat,\n      setActiveChat,\n      handleModal,\n      closeModal,\n      handleSearchSubmit,\n      updateSearchValue,\n      chats,\n      setChats,\n      showModal,\n      setSideBarCategory,\n      sideBarCategory,\n      modalType,\n      fetchChats,\n      setShowModal,\n      showAddUserInfoDropdown,\n      setShowAddUserInfoDropdown,\n      setUserInfoModal,\n      activeUserInfo,\n      isActiveUserCurrentUser,\n      setIsActiveUserCurrentUser,\n      showActiveUserWithinChatInfo,\n      setShowActiveUserWithinChatInfo,\n      setActiveUserInfo,\n      isChatViewLoading,\n      activeView,\n      setActiveView,\n      windowDimensions,\n      notifications,\n      setNotifications,\n      setWindowDimensions,\n      setReloadCircuit,\n      fetchNotifications,\n      unreadMessages,\n      setUnreadMessages\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 242,\n    columnNumber: 5\n  }, this);\n};\n\n_s2(ChatViewProvider, \"sGROE/2/fhGE+ucAU+OE5hwbWSs=\", false, function () {\n  return [useAuthentication, useNavigate];\n});\n\n_c = ChatViewProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"ChatViewProvider\");","map":{"version":3,"names":["createContext","useContext","useEffect","useState","useCallback","useAuthentication","toast","useNavigate","ChatViewContext","useChatView","SIDEBAR_CATEGORY_TYPE","conversations","friends","MODAL_TYPE","sidebar","chatInfo","userInfo","ChatViewProvider","children","activeChat","setActiveChat","search","setSearch","isChatViewLoading","setIsChatViewLoading","searchResults","setSearchResults","sideBarCategory","setSideBarCategory","showModal","setShowModal","showAddUserInfoDropdown","setShowAddUserInfoDropdown","modalType","setModalType","chats","setChats","activeUserInfo","setActiveUserInfo","isActiveUserCurrentUser","setIsActiveUserCurrentUser","showActiveUserWithinChatInfo","setShowActiveUserWithinChatInfo","activeView","setActiveView","windowDimensions","setWindowDimensions","height","window","innerHeight","width","innerWidth","notifications","setNotifications","reloadCircuit","setReloadCircuit","unreadMessages","setUnreadMessages","currentUser","setCurrentUser","setIsLoading","navigate","closeModal","setUserInfoModal","id","currentUserFlag","response","fetch","method","headers","Authorization","token","user","json","updateSearchValue","e","target","value","fetchChats","tokenForLogin","userData","data","success","position","autoClose","hideProgressBar","closeOnClick","pauseOnHover","draggable","progress","undefined","theme","error","fetchNotifications","console","log","handleModal","handleSearchSubmit","preventDefault","messages","users","_id","length"],"sources":["/Users/griffinbaker/Desktop/chat-application/client/src/contexts/chat-view-context.js"],"sourcesContent":["import {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  useCallback,\n} from 'react';\nimport { useAuthentication } from './authentication-context';\nimport { toast } from 'react-toastify';\nimport { useNavigate } from 'react-router-dom';\n// import { useSocket } from './socket-context';\n\nconst ChatViewContext = createContext();\n\nexport const useChatView = () => useContext(ChatViewContext);\n\nexport const SIDEBAR_CATEGORY_TYPE = {\n  conversations: 'conversations',\n  friends: 'friends',\n};\n\nexport const MODAL_TYPE = {\n  sidebar: 'sidebar',\n  chatInfo: 'chatInfo',\n  userInfo: 'userInfo',\n};\n\nexport const ChatViewProvider = ({ children }) => {\n  const [activeChat, setActiveChat] = useState([]);\n  const [search, setSearch] = useState('');\n  const [isChatViewLoading, setIsChatViewLoading] = useState(false);\n  const [searchResults, setSearchResults] = useState([]);\n  const [sideBarCategory, setSideBarCategory] = useState(\n    SIDEBAR_CATEGORY_TYPE.conversations\n  );\n  const [showModal, setShowModal] = useState(false);\n  const [showAddUserInfoDropdown, setShowAddUserInfoDropdown] = useState(false);\n  const [modalType, setModalType] = useState('');\n  const [chats, setChats] = useState([]);\n  const [activeUserInfo, setActiveUserInfo] = useState(null);\n  const [isActiveUserCurrentUser, setIsActiveUserCurrentUser] = useState(false);\n  const [showActiveUserWithinChatInfo, setShowActiveUserWithinChatInfo] =\n    useState(false);\n  const [activeView, setActiveView] = useState('chat');\n  const [windowDimensions, setWindowDimensions] = useState({\n    height: window.innerHeight,\n    width: window.innerWidth,\n  });\n  const [notifications, setNotifications] = useState([]);\n  const [reloadCircuit, setReloadCircuit] = useState(false);\n  const [unreadMessages, setUnreadMessages] = useState([]);\n\n  const { currentUser, setCurrentUser, setIsLoading } = useAuthentication();\n  const navigate = useNavigate();\n\n  const closeModal = () => {\n    if (showAddUserInfoDropdown) {\n      setShowAddUserInfoDropdown(false);\n      return;\n    }\n    setShowModal(false);\n  };\n\n  const setUserInfoModal = async (id, currentUserFlag = null) => {\n    if (currentUserFlag) {\n      setActiveUserInfo(currentUser);\n      setIsActiveUserCurrentUser(true);\n      setShowActiveUserWithinChatInfo(true);\n      return;\n    }\n    const response = await fetch(\n      `http://localhost:4000/api/user/getUserInfo?id=${id}`,\n      {\n        method: 'get',\n        headers: { Authorization: `Bearer ${currentUser.token}` },\n      }\n    );\n    const user = await response.json();\n    setActiveUserInfo(user);\n  };\n\n  const updateSearchValue = e => setSearch(e.target.value);\n\n  const fetchChats = useCallback(\n    async (tokenForLogin = null, userData = null) => {\n      setIsChatViewLoading(true);\n      setIsLoading(true);\n      try {\n        const response = await fetch(`http://localhost:4000/api/chat`, {\n          method: 'get',\n          headers: {\n            Authorization: `Bearer ${tokenForLogin || currentUser.token}`,\n          },\n        });\n        const data = await response.json();\n        setIsChatViewLoading(false);\n        setIsLoading(false);\n        setChats(data);\n        if (tokenForLogin) {\n          navigate('/chat');\n          toast.success('Login success', {\n            position: 'bottom-center',\n            autoClose: 3000,\n            hideProgressBar: false,\n            closeOnClick: true,\n            pauseOnHover: true,\n            draggable: true,\n            progress: undefined,\n            theme: 'dark',\n          });\n          setCurrentUser(userData);\n        }\n      } catch (e) {\n        setIsChatViewLoading(false);\n        toast.error('Error fetching chats', {\n          position: 'bottom-center',\n          autoClose: 3000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n          progress: undefined,\n          theme: 'dark',\n        });\n      }\n    },\n    [currentUser, navigate, setIsLoading, setCurrentUser]\n  );\n\n  const fetchNotifications = useCallback(\n    async (tokenForLogin = null) => {\n      try {\n        const response = await fetch(`http://localhost:4000/api/notification`, {\n          method: 'get',\n          headers: {\n            Authorization: `Bearer ${tokenForLogin || currentUser.token}`,\n          },\n        });\n        const notifications = await response.json();\n        console.log(notifications, 'notifications');\n        setNotifications(notifications);\n        // const chatAndReadStatus = [];\n        // if (notifications.length === 0) return;\n        // notifications.forEach(notification => {\n        //   const alreadyInCounterIndex = chatAndReadStatus.findIndex(\n        //     notificaitonInChatCounter =>\n        //       notificaitonInChatCounter.chat._id ===\n        //       notification.message.chat._id\n        //   );\n        //   if (alreadyInCounterIndex >= 0) {\n        //     let objToInc = chatAndReadStatus[alreadyInCounterIndex];\n        //     objToInc.count = objToInc.count + 1;\n        //   } else {\n        //     chatAndReadStatus.push({ notification, read: false });\n        //   }\n        // });\n      } catch (error) {\n        toast.error('Error fetching notifications', {\n          position: 'bottom-center',\n          autoClose: 3000,\n          hideProgressBar: false,\n          closeOnClick: true,\n          pauseOnHover: true,\n          draggable: true,\n          progress: undefined,\n          theme: 'dark',\n        });\n      }\n    },\n    [currentUser]\n  );\n\n  const handleModal = modalType => {\n    setModalType(modalType);\n    setShowModal(true);\n  };\n\n  const handleSearchSubmit = async e => {\n    e.preventDefault();\n    if (!search) return;\n\n    try {\n      setIsChatViewLoading(true);\n\n      // I almost like the feature where you keep the search text there so that you know what you searched, and then once you hit the x then the results unfilter and are based off of the time the last message was sent\n      // setSearch('');\n\n      const response = await fetch(\n        `http://localhost:4000/api/user?search=${search}`,\n        {\n          method: 'get',\n          headers: { Authorization: `Bearer ${currentUser.token}` },\n        }\n      );\n      const { messages, users } = await response.json();\n      setIsChatViewLoading(false);\n      setSearchResults([{ messages, users }]);\n    } catch (e) {\n      toast.error('Error fetching results', {\n        position: 'bottom-center',\n        autoClose: 3000,\n        hideProgressBar: false,\n        closeOnClick: true,\n        pauseOnHover: true,\n        draggable: true,\n        progress: undefined,\n        theme: 'dark',\n      });\n    }\n  };\n\n  // Fetch the chats once, and then otherwise just add the chats to the data, don't need to re-fetch or anything like that. Could keep this here or do something where you only fetch the chats and the friends once the user is actually signed in. That could also be a route where you just find these two things\n\n  useEffect(() => {\n    if (!currentUser) {\n      setChats([]);\n      setActiveChat([]);\n      return;\n    }\n    if (currentUser._id) {\n      fetchChats();\n      fetchNotifications();\n    }\n    return;\n  }, [currentUser, fetchChats, setIsLoading, fetchNotifications]);\n\n  useEffect(() => {\n    if (chats.length === 0 || reloadCircuit) {\n      return;\n    } else {\n      const activeChat = chats[0];\n      setActiveChat([activeChat]);\n    }\n  }, [chats, reloadCircuit]);\n\n  // useEffect(() => {\n  //   if (!currentUser) return;\n  //   setFriends(currentUser.friends);\n  // }, [currentUser]);\n\n  return (\n    <ChatViewContext.Provider\n      value={{\n        activeChat,\n        setActiveChat,\n        handleModal,\n        closeModal,\n        handleSearchSubmit,\n        updateSearchValue,\n        chats,\n        setChats,\n        showModal,\n        setSideBarCategory,\n        sideBarCategory,\n        modalType,\n        fetchChats,\n        setShowModal,\n        showAddUserInfoDropdown,\n        setShowAddUserInfoDropdown,\n        setUserInfoModal,\n        activeUserInfo,\n        isActiveUserCurrentUser,\n        setIsActiveUserCurrentUser,\n        showActiveUserWithinChatInfo,\n        setShowActiveUserWithinChatInfo,\n        setActiveUserInfo,\n        isChatViewLoading,\n        activeView,\n        setActiveView,\n        windowDimensions,\n        notifications,\n        setNotifications,\n        setWindowDimensions,\n        setReloadCircuit,\n        fetchNotifications,\n        unreadMessages,\n        setUnreadMessages,\n      }}\n    >\n      {children}\n    </ChatViewContext.Provider>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
1) First things first is to make that login page so that I can generate an ID for each user, store them in the DB in the users collection

- Include a sign in and sign up page very similar to the one that we used for the smart-brain app, this time using mongodb
-> Once this person signs in, we receive an id back from mongo that can be the identifier for that person
-> Can secure the password as well using bcrypt

- In the application itself, obviously need to make everything work so that the messages for each chat show up

DATA ORGANIZATION:
- I am thinking that each chat room will also have an identifier saved with it as well

DIFFERENT IDS THAT I NEED:
- USER ID
- CHAT ID, WHICH CONTAINS THE USER IDS

KEEP IN MIND THAT IN EACH FETCH THAT WE ARE GOING TO MAKE TO OUR BACKEND, THAT INSIDE THE FETCH WE CAN JUST ESSENTIALLY CONSTRUCT THESE ROUTES OURSELF AND WE NEED TO HAVE MATCHING ROUTES IN OUR BACKEND THAT CAN RESPOND WITH WHAT WE WANT THEM TO

IN MY AUTHENTICATION PROVIDER, I CAN ALSO GET AND ADD THE CURRENT USER, SO THAT IS PERFECT TO THEN BE ABLE TO SHARE THAT INFORMATION ACROSS THE REST OF THE APPLICATION

IN THE DROPDOWN THAT I AM GOING TO INCLUDE, MAYBE HAVE A LITTLE THING AS WELL WHERE IT CAN SHOW YOU WHERE ALL OF YOUR FRIEND REQUESTS ARE, WOULD ALSO BE COOL TO HAVE YOUR MESSAGES UPDATED AND YOU CAN SEE IF YOU HAVE READ IT OR NOT (NOT SURE IF WE ARE GOING TO IMPLEMENT THAT OR NOT BUT THAT WOULD BE PRETTY COOL)

ALSO WHETHER OR NOT SOMEONE IS ONLINE COULD BE A COOL FEATURE AS WELL

YOU WANT TO UPLOAD THE PICTURES THAT THE USERS UPLOAD TO THE CLOUD BECUASE HOW ELSE WILL YOU BE ABLE TO ACCESS THEM FROM INSIDE THE APPLICATION?

YOU GENERATE THESE TOKENS FOR PEOPLE THAT YOU DON'T ACTUALLY NEED TO STORE ANYWHERE, YOU JUST NEED TO CHECK IF THEY WERE VALIDLY GENERATED BY CKECING THE TOEKN THAT THEY RECEIVED AND THEN YOUR SECRET KEY AND THEN THEY WILL BE ABLE TO EXTRACT FORM THAT THE ID

SO I THINK THERE IS SOMETHING WHERE IF YOU DON'T POPULATE THE OBJECT, IT JUST REMAINS AS THE ACTUAL OBJECT ID SINCE THAT IS WHAT YOU SAY THE TYPE IS ACTUALLY GOING TO BE, BUT YOU CAN THEN POPULATE THE DATA IN LIEU OF THE ACTUAL ID IN THE DATA STRUCTURE

SO MY UNDERSTANDING IS THAT YOU CAN MATCH BY THE OBJECT ID, BUT IF YOU WANT TO FILL IN THE ACTUAL FIELDS IN THE DATA THAT YOU SEND BACK THEN YOU NEED TO "POPULATE", SO THIS IS RELEVANT WHEN YOU ARE FINDING THINGS BASED ON A PROPERTY WHICH IS OF TYPE OBJECT.ID

HOW DOES CONTEXT ACTUALLY WORK IN REACT BECAUSE IT IS SUCH A COOL CONCEPT, IT IS LIKE YOU ARE JUST CREATING AN OBJECT THAT ESSENTIALLY YOU KEEP IN MEMORY WITH CLOSURES AND CAN ACCESS FROM DIFFERENT FUNCTIONS AND THERE IS ONLY ONE OF THESE STATE OBJECTS SO THAT IT CAN RETAIN A CONNECTION

ONCE YOU START STORING FRIENDS AS WELL I WOULD THINK THAT IT WOULD ACTUALLY BE PRETTY EASY TO JUST PULL IN SOMEONE ELSE'S FRIENDS ONCE YOU HAVE THEIR ID SO THAT YOU CAN FIND IT IN THE DB

COULD POTENTIALLY ALSO INCLUDE A AN IMAGE OF WHO ACTUALLY SENDS THE MESSAGE LIKE IN DISCORD

YOU WOULD ALSO HAVE THE CHAT RESULTS AND ALL OF THAT DATA ALREADY ON THE CLIENT SIDE I GUESS, SO THEN IT WOULD JUST BE A MATTER OF SORTING THROUGH THE DATA THAT YOU ALREADY PULLED AND THAT EXISTS CLIENT SIDE RIGHT? SO WHEN THE USER LOGS IN YOU PULL THEIR CONVERSATIONS AND FRIENDS AND HAVE THEM DISPLAY ON THE LEFT AND THEN SEARCHING IS JUST A FUNCTION OF SORTING THROUGH THAT STUFF? YEAH

SO WHEN YOU GO TO CREATE A CHAT AND THEN IF YOU DO NOT FIND A CHAT WITH THOSE PEOPLE, THEN YOU CAN ACTUALLY CREATE IT AND INCLUDE IT

ADD FRIENDS TO THE USER MODEL THAT NEED TO GET ADDED IN SO THAT THEIR FRIENDS LOAD AND THEN ACTUALLY CAN GET LOADED IN

I ALSO WILL BE USING THAT SEARCH ALL THE USERS ROUTE WHEN I GO TO ADD A FRIEND BECAUSE IF IT MATCHES NAYTHING AT ALL THEN YOU SHOULD BE ABLE TO FRIEND THA TPERSON SO NEED TO BE RETURNING AT LEAST A SEGMENT OF THE FRIENDS FOR WHOM THAT THERE IS A MATCH

FOR THE SEARCH BAR FUNCTIONALITY ON THE LEFT, WHAT I AM CURRENLTY THINKING IS THAT WE COULD JUST SHOW, INSTEAD OF THE MOST RECENT MESSAGE, THE MESSAGE THAT WE FOUND THAT PERTAINED TO THE SEARCH RESULT OF THE USER, AND THEN WHEN THEY CLICK TO THAT CHAT, THEY SHOULD BE TAKEN RIGHT TO THAT MESSAGE

FEATURES STILL TO ADD:
- REMOVING AND ADDING FRIENDS
- MESSAGE VIEW INFO BUTTON THAT SHOWS YOU THE USERS IN THE CHAT, ALLOWS YOU TO RENAME THE CHAT AND LEAVE THE GROUP, IT WILL ALSO SHOW YOU WHO IS IN THE CHAT, THE USERS IN THE CHAT, AND WHEN YOU CLICK ON THEM IT WILL SHOW YOU A POPUP OF THEIR INFORMATION; THIS COULD BE THE COMPONENT WHERE IT SHOWS THEIR FRIENDS AND YOU COULD CHECK OUT THEIR FRIENDS, REMOVE THEM AS A FRIEND, ETC.
- SIDEBAR SEARCH BAR
- ADDING MESSAGES TO THE CHAT AND SHOWING THEM IN THE CHAT VIEW; WORK ON THE CHAT VIEW MORE GENERALLY CERTAIN NEEDS TO BE DONE
- JUST FOR SOMETHING DIFFERENT AS WELL, ON THE CHAT INFO BUTTON MODAL, I WOULD LIKE THAT TO BE JUST THE IMAGE AND THEIR USERNAME UNDER IT, JUST FOR SOMETHING DIFFERENT STYLISTICALLY 
- MODALS THAT I NEED:
=> CHAT INFO MODAL
=> USERINFO MODAL WHEN YOU CLICK ON A USER FROM HERE

LOOK INTO THE DISPATCH EVENT AS WELL

IN THE FRIENDS COLUMN BEING ABLE TO SEE WHO IS ONLINE OR NOT IS ALSO A PRETTY COOL FEATURE

THE PROGRESS BAR IN GENERAL IS ALSO A PRETTY COOL FEATURE TO BE ABLE TO INCLUDE

THEN IN THE INFO MODAL THAT POPS UP WITHIN THE CHAT YOU WOULD WANT TO ACCESS THE CHAT PARTICIPANTS AND INCLUDE ONE ROW FOR EACH PARTICIPANT SO WHEN YOU CLICK THEN IT WOULD NEED TO GO TO THE USER INFO MODAL, COULD THEN ALSO INCLUDE A BACK BUTTON PERHAPS

YOU CAN JUST LITERALLY HAVE THE USER INFO MODAL POPUP WHEN YOU CLICK ON AN ARROW AND SET THE CURRENT USER TO WHOEVER YOU JUST CLICKED AND THEN WHEN YOU HIT THE BACK BUTTON SET THE MODAL TYPE TO THE CHAT INFO PAGE OF THE CURRENT CHAT WHICH SHOULD STILL BE SAVED, OR YOU COULD TRY TO DO SOME FANCY STUFF WITH HIDING THE DISPLAY I GUESS, THAT MIGHT BE THE FASTEST PERFORMANCE WISE

WITH STRING INTERP YOU PUT AN EXPRESSION WITH THE DOLLAR SIGN VALUE INSIDE OF THE LITERAL; AN EXPRESSION IS JUST SOMETHING THAT EVALUATES TO A VALUE

SOMEHOW ALSO NEED TO KNOW WHETHER THE DROPDOWN IS OPEN, AND IF IT IS, THEN WHEN THERE IS A CLICK MAKE SURE THAT THE CLICK IS ONLY FOR THE WINDOW AND THEN STOP PROPAGATION SO THAT THAT IS THE ONLY THING THAT CLOSES. YEAH SO WITH IMESSAGE WHEN YOU CLICK THAT IS THE ONE THAT CLOSES REGARDLESS.

STILL HAVE TO DO THE:
- WHAT I AM GOING TO DO NOW IS THAT WHENEVER YOU CLICK ON A SOLO CHAT OR CLICK ON SOMEONE FROM THE CHAT VIEW YOU SHOULD BE ABLE TO SEE THEIR PROFILE, WITH A BACK BUTTON IN THE LAST CASE AND AN X BUTTON IN THE FROMER
- ADD FRIEND
- MESSAGE FUNCTIONALITY, NOTIFICATIONS WHEN YOU GET NEW MESSAGES
- SOCKETS
- User profile on the dropdown that just opens a modal but for the user themselves, they are the id instead of anyone else that you click on

WHAT I NEED TO DO IS DO THE GENERATE NAME FOR SOLO CHATS AND MAKE THAT THE CHAT NAME. THEN ALSO SET A FLAG TO SEE IF IT IS  GROUP CHAT. YOU ARE ALREADY DOING IT ON THE SIDEBAR, JUST DO IT FROM THE START ON THE SERVER SIDE AND KEEP THINGS CLEAN AND CONSISTENT (SINGLE SOURCE OF TRUTH).

INSTEAD OF DOING IT WITH THE CHAT NAME, JUST DO THIS WITH A FLAG AND THEN SET THE CHAT NAME DEPENDING ON WHO THE CURRENT USER IS TO SET THE OPPOSITE AND JUST SET THE NAME

FOR THE NOTIFICATION BELL, INCLUDE A NOTIFICATION FOR EACH NEW FRIEND REQUEST AND THEN FOR EACH CHAT THAT HAS NEW MESSAGES (FOR EACH CHAT THAT ALREADY HAS UNREAD MESSAGES, JUST SAY THAT THERE ARE X NEW MESSAGES IN THE CHAT, AND LEAVE IT AT THAT)

THERE IS SOME WEIRD SHIT GOING ON WITH THE IS LOADING BECAUSE I WAS TRYING TO USE IT ACROSS BOTH THE AUTH AND THE CHAT VIEW OR SOMETHING LIKE THAT AND THE END RESULT IS THAT SHIT IS JUST WEIRD RIGHT NOW..

QUERY VS PARAMS VS BODY

ALIGNING CONTENTS WITHIN A FLEX BOX AND WHETHER OR NOT THEY GROW, LIKE ALIGN START, AND THEN THEY DID NOT GROW IN THE ACTUAL MESSAGE BUBBLE


import { useCallback, useEffect, useState } from 'react';
import { io } from 'socket.io-client';
import Lottie from 'lottie-react';
import { useChatView } from '../../contexts/chat-view-context';
import Spinner from '../spinner/spinner.component';
import './message-view.styles.scss';
import { useAuthentication } from '../../contexts/authentication-context';
import animationData from '../../animations/typing.json';
import {
  defaultToast,
  sameSenderAndNotCurrentUser,
  TOAST_TYPE,
  userSent,
} from '../../utils/utils';

// Could definitely add timestamp data to the message as well, that would be pretty clean actually

const ENDPOINT = 'http://localhost:4000';
let socket;

const defaultOptions = {
  loop: true,
  autoplay: true,
  animationData: animationData,
  rendererSettings: {
    preserveAspectRatio: 'xMidYMid slice',
  },
};

const MessageView = () => {
  // Somehow we are going to have to get all of the message in a conversation potentially and then mark whether or not they are your messages or someone else's to style accordingly;
  const { currentUser } = useAuthentication();
  const { activeChat } = useChatView();

  // const [socketConnected, setSocketConnected] = useState(false);
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [typing, setTyping] = useState(false);
  const [typers, setTypers] = useState([]);

  // So I am thinking that I can definitely scroll into view whatever message is actually clicked within whatever chat, I don't see why that would not be possible?
  // Pretty cool, when the component actually mounts, the ref for the element gets passed into the callback function, could actually do some pretyy coll things with this, like making an animation or shake the screen or bounce the message or anything when the message actually enters the screen...

  const handleKeyDown = async e => {
    const newMessage = e.target.innerHTML;
    if (e.key === 'Enter' && newMessage) {
      e.preventDefault();
      e.target.innerHTML = '';
      try {
        const response = await fetch(`http://localhost:4000/api/message`, {
          method: 'post',
          headers: {
            Authorization: `Bearer ${currentUser.token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            chatId: activeChat[0]._id,
            text: newMessage,
          }),
        });
        const message = await response.json();
        socket.emit('new message', message);
        setMessages(prevState => [...prevState, message]);
      } catch (error) {
        defaultToast(TOAST_TYPE.error, 'Error sending');
      }
    } else {
      if (!typing) {
        console.log('hey');
        setTyping(true);
        socket.emit('typing', activeChat[0]._id, currentUser);
      }
      let lastTypingTime = new Date().getTime();
      var timerLength = 5000;
      setTimeout(() => {
        var timeNow = new Date().getTime();
        var timeDiff = timeNow - lastTypingTime;
        if (timeDiff >= timerLength) {
          socket.emit('stop typing', activeChat[0]._id, currentUser);
          setTyping(false);
        }
      }, timerLength);
    }
  };

  const fetchMessages = useCallback(async () => {
    if (!activeChat) return;
    setIsLoading(true);
    const response = await fetch(
      `http://localhost:4000/api/message/${activeChat[0]._id}`,
      {
        method: 'get',
        headers: { Authorization: `Bearer ${currentUser.token}` },
      }
    );
    const messages = await response.json();
    setMessages(messages);
    setIsLoading(false);

    socket.emit('join chat', activeChat[0]._id);
  }, [activeChat, currentUser.token]);

  useEffect(() => {
    fetchMessages();
  }, [fetchMessages, activeChat]);

  useEffect(() => {
    console.log('running');
    socket = io(ENDPOINT);
    socket.emit('setup', currentUser);
    // For when the user refreshes the page or leaves the chat, otherwise the lottie is suspended
    socket.emit('stop typing', activeChat[0]._id, currentUser);
    socket.on('typing', typer => {
      setIsTyping(true);
      setTypers(prevState => [typer, ...prevState]);
    });

    return () => socket.disconnect();
  }, [currentUser, activeChat]);

  useEffect(() => {
    socket.on('stop typing', userName => {
      console.log(
        'the user who just stopped',
        userName,
        'the current typers',
        typers
      );
      // debugger;
      const usersStillTyping = typers.filter(typer => typer !== userName);
      console.log(usersStillTyping, 'users still typing');
      if (usersStillTyping.length > 0) {
        setTypers(usersStillTyping);
        return;
      }
      console.log('running and should not be?');
      setIsTyping(false);
      setTypers([]);
    });
  }, [typers]);

  useEffect(() => {
    socket.on('message received', message => {
      console.log('yo');
      setIsTyping(false);
      if (!activeChat[0]._id || message.chat._id !== activeChat[0]._id) {
        // give notification
        console.log('fail some how');
      } else {
        setMessages(prevState => {
          return [...prevState, message];
        });
      }
    });
  }, [activeChat]);

  const setRef = useCallback(node => {
    if (node) {
      node.scrollIntoView({ smooth: true });
    }
  }, []);

  // What is the best way to make it so that the text bubble can expland if it needs to??
  return (
    <div className="message-view-container">
      {isLoading ? (
        <Spinner type="search" />
      ) : (
        <>
          <div className="message-view-active-chat-container">
            {messages.length > 0 &&
              messages.map((message, i) => {
                const lastMessageBool = messages.length - 1 === i + 1;
                const userSentBool = userSent(currentUser, message);
                const sameSenderAndNotCurrentUserBool =
                  sameSenderAndNotCurrentUser(i, messages, currentUser);
                return (
                  <div
                    key={i}
                    ref={lastMessageBool ? setRef : null}
                    className={`message-view-message-container ${
                      userSentBool ? 'user-sent' : ''
                    }`}
                  >
                    <div
                      className="message-view-message-image-container"
                      style={
                        sameSenderAndNotCurrentUserBool || userSentBool
                          ? { visibility: 'hidden' }
                          : { marginTop: '2px' }
                      }
                    >
                      <img
                        height="100%"
                        src={message.sender.picture}
                        alt="profile"
                      />
                    </div>
                    <div className="message-view-text-container">
                      <div className="message-view-text">{message.text}</div>
                      <div
                        style={
                          sameSenderAndNotCurrentUserBool || userSentBool
                            ? { display: 'none' }
                            : {}
                        }
                        className="message-view-text-info"
                      >
                        <p>
                          @{!userSentBool ? message.sender.userName : 'You'}
                        </p>
                      </div>
                    </div>
                  </div>
                );
              })}
            {isTyping && (
              <div ref={isTyping ? setRef : null} className="lottie-container">
                {typers.length
                  ? typers.map((typer, i) => <p key={i}>@{typer} is typing</p>)
                  : ''}
                <Lottie
                  animationData={animationData}
                  loop={true}
                  autoplay={true}
                  style={{ height: '16px' }}
                />
              </div>
            )}
          </div>

          <div
            className="send-message-editable"
            data-text={`Message `}
            contentEditable
            onKeyDown={handleKeyDown}
          />
        </>
      )}
    </div>
  );
};

export default MessageView;
